#lang racket

(define (print thingy)
  (display thingy)
  (display "\n"))

(define (make-binary-tree comparer)
  (define (make-node key val)
    (mcons (mcons key val) (mcons '() '())))
  (define (get-key node)
    (mcar (mcar node)))
  (define (get-val node)
    (mcdr (mcar node)))
  (define (get-next node)
    (mcdr (mcdr node)))
  (define (get-prev node)
    (mcar (mcdr node)))
  (define (set-val! node)
    (set-mcdr! (mcar node)))
  (define (set-next! node new)
    (set-mcdr! (mcdr node) new))
  (define (set-prev! node new)
    (set-mcar! (mcdr node) new))
  (define (set-item! node new)
    (set-mcar! node new))
  
  (define (find key current-node)
    (let ((curr-key (get-key current-node)))
      (cond ((equal? key curr-key) current-node)
            ((comparer key curr-key)
             (if (null? (get-prev current-node))
                 current-node
                 (find key (get-prev current-node))))
             (else
              (if (null? (get-next current-node))
                  current-node
                  (find key (get-next current-node)))))))
  
  (let ((local-tree '()))
    (define (empty?)
      (null? local-tree))
    (define (insert key val)
      (if (empty?)
          (set! local-tree (make-node key val))
          (let ((result (find key local-tree)))
            (cond ((equal? key (get-key result))
                   (set-val! result val))
                  ((comparer key (get-key result))
                   (set-prev! result (make-node key val)))
                  (else
                   (set-next! result (make-node key val)))))))
    (define (lookup key)
      (if (empty?)
          false
          (let ((result (find key local-tree)))
            (if (equal? key (get-key result))
                (get-val result)
                false))))
    (define (tree-print)
      (define (print-iter current-node)
        (if (null? current-node) '()
            (begin
              (display "Key: ")
              (print (get-key current-node))
              (display "Value: ")
              (print (get-val current-node))
              (print-iter (get-prev current-node))
              (print-iter (get-next current-node)))))
      (if (empty?) (print "Tree is empty!")
          (print-iter local-tree)))
    (lambda (m)
      (print local-tree)
      (cond ((eq? m 'find) find)
            ((eq? m 'lookup) lookup)
            ((eq? m 'insert) insert)
            ((eq? m 'print) (tree-print))
            (else
             (error "BINARY-TREE Unknown command" m))))))


(define (tree-insert tree key val)
  ((t 'insert) key val))
(define (tree-lookup tree key)
  ((tree 'lookup) key))
(define (tree-print tree)
  (tree 'print))

(define t (make-binary-tree string<?))
(tree-insert t "a" 1)
(print 'ok)
(tree-insert t "aa" 2)
(tree-insert t "ab" 3)
(tree-lookup t "ab")
(tree-lookup t "aa")
(tree-lookup t "c")
(tree-insert t "What's all this?" 10)
(tree-print t)